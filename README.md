# BCZY2
第二次编程作业
1.线索二叉树：我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树
2.建立一个线索二叉树：（1）把这棵二叉树进行中序遍历后，将所有的空指针域中的rchild，改为指向它的后继结点。（2）将这棵二叉树的所有空指针域中的lchild，改为指向当前结点的前驱。
3.对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。
4.我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。
ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。rtag为0时指向该结点的右孩子，为1时指向该结点的后继。
5.树、森林与二叉树的转换
（1）树转换为二叉树
1)加线。在所有兄弟结点之间加一条连线。
2)去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
3)层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。
<img width="177" alt="image" src="https://user-images.githubusercontent.com/111118849/185789840-ed25212c-e4bd-4bf9-9fb8-d958cbd327ae.png">
<img width="212" alt="image" src="https://user-images.githubusercontent.com/111118849/185789865-e044e749-180a-434b-977e-9fa791930c90.png">
（2）森林转换为二叉树
1）把每个树转换为二叉树。 
2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。
（3）二叉树转换为树
1）加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。 
2）去线。删除原二叉树中所有结点与其右孩子结点的连线。
3）层次调整。使之结构层次分明。
<img width="200" alt="image" src="https://user-images.githubusercontent.com/111118849/185789866-855e42ad-1be0-4f12-9a36-d29ebba261a8.png">
例图：<img width="175" alt="image" src="https://user-images.githubusercontent.com/111118849/185789876-37bc9dbf-ee2a-423a-9b6b-2edb1f5c23f6.png">
（4）二叉树转换为森林
1）从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。 
2）再将每棵分离后的二叉树转换为树即可。
（5）树与森林的遍历
1）树的遍历分为两种方式： 1，一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。 2，另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。如例图，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。
2）森林的遍历也分为两种方式： 1.前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。如例图，前序遍历序列的结果就是ABCDEFGHJI。 2.后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。如例图，后序遍历序列的结果就是BCDAFEJHIG。
6.赫夫曼编码：最基本的压缩编码方法
7.赫夫曼树：其中带权路径长度WPL最小的二叉树称做赫夫曼树
8.如何构造赫夫曼树：
1）先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。
2）取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子。
3）将N1替换A与E，插入有序序列中，保持从小到大排列。即：N15，B15，D30，C40。
4）重复步骤2。将N1与B作为一个新节点N2的两个子结点。
5）将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N30，D30，C40。
6）重复步骤2。将N2与D作为一个新节点N3的两个子结点。
7）将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N60。
8．重复步骤2。将C与N3作为一个新节点T的两个子结点。由于T即是根结点，完成赫夫曼树的构造。
<img width="94" alt="image" src="https://user-images.githubusercontent.com/111118849/185789886-701453bc-2405-48d0-ac1e-7f4e3065f69b.png">
<img width="94" alt="image" src="https://user-images.githubusercontent.com/111118849/185789893-15b1c9df-9073-47e0-a413-d371e947d5f7.png">
<img width="101" alt="image" src="https://user-images.githubusercontent.com/111118849/185789897-79046440-7234-4368-841b-215835153b98.png">
<img width="101" alt="image" src="https://user-images.githubusercontent.com/111118849/185789904-d7cdb533-d639-4723-b7e7-9b8dce2cf38c.png">
9.赫夫曼算法描述:
1)根据给定的n个权值{w1,w2,...,wn}构成n棵二叉树的集合F={T1,T2,...,Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。
2)在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3)在F中删除这两棵树，同时将新得到的二叉树加入F中。
4)重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。
10. 赫夫曼编码：作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码。
11.图：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。在图结构中，不允许没有顶点。顶点之间的逻辑关系用边来表示，边集可以是空的。
12.无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。
有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧。用有序偶<vi,vj>来表示，vi称为弧尾，vj称为弧头。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。
<img width="176" alt="image" src="https://user-images.githubusercontent.com/111118849/185789930-27f47a21-b270-4b24-b369-fb867b39746c.png">
<img width="195" alt="image" src="https://user-images.githubusercontent.com/111118849/185789933-610f699d-2200-4e18-bfc9-3bae47852370.png">
G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}
G2=(V2,{E2})，其中顶点集合V2={A,B,C,D}；弧集合E2={<A,D>,<B,A>,<C,A>,<B,C>}
13.若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图
14.在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。
<img width="184" alt="image" src="https://user-images.githubusercontent.com/111118849/185789941-1bac2a15-eb2c-4378-81ac-c8af14451177.png">
<img width="215" alt="image" src="https://user-images.githubusercontent.com/111118849/185789955-185d9927-f202-4a5c-89b1-71e268b9aad0.png">
15.在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。
16.有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。
17.G<img width="96" alt="image" src="https://user-images.githubusercontent.com/111118849/185789969-3d36c252-93d0-46a0-a89c-ccdc9195c6ff.png">
G’<img width="289" alt="image" src="https://user-images.githubusercontent.com/111118849/185789975-817c3c41-2c7c-4018-b8c9-83ac98eb90b6.png">
  G’图为G图的子图
18.对于无向图G=(V,{E})，如果边(v,v')∈E，则称顶点v和v'互为邻接点。顶点v的度是和v相关联的边的数目，记为TD(v)。边数其实就是各顶点度数和的一半。
19.对于有向图G=(V,{E})，如果弧<v,v'>∈E，则称顶点v邻接到顶点v'，顶点v'邻接自顶点v。弧<v,v'>和顶点v，v'相关联。以顶点v为头的弧的数目称为v的入度，记为ID(v)；以v为尾的弧的数目称为v的出度，记为OD(v)；TD(v)=ID(v)+OD(v)。
20.树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。
21.第一个顶点和最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。
22.在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图。
23.无向图中的极大连通子图称为连通分量。注意连通分量的概念，它强调：1）要是子图；2）子图要是连通的；3）连通子图含有极大顶点数；4）具有极大顶点数的连通子图包含依附于这些顶点的所有边。
<img width="212" alt="image" src="https://user-images.githubusercontent.com/111118849/185789981-00c91cbe-137d-4295-914f-7eefdcf37ef3.png">
<img width="168" alt="image" src="https://user-images.githubusercontent.com/111118849/185789985-7d0a8ea8-540c-4880-a3ae-189cd8fca69b.png">
图1是一个无向非连通图。但是它有两个连通分量，即图2和图3。而图4，尽管是图1的子图，但是它却不满足连通子图的极大顶点数（图2满足）。因此它不是图1的无向图的连通分量。
24.在有向图G中，如果对于每一对vi、vj∈V、vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。
<img width="203" alt="image" src="https://user-images.githubusercontent.com/111118849/185789991-19de0464-50f6-4061-a743-796c6d5a9e03.png">
图1并不是强连通图，因为顶点A到顶点D存在路径，而D到A就不存在。图2就是强连通图，而且显然图2是图1的极大强连通子图，即是它的强连通分量。
25.连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。有n-1条边并不一定是生成树。
26.如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1边条，必定构成一个环。
27.如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一个有向树。
28.一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。
<img width="327" alt="image" src="https://user-images.githubusercontent.com/111118849/185790008-45d59520-fada-4d92-894f-25acc573517f.png">
图1是一棵有向图。去掉一些弧后，它可以分解为两棵有向树，如图2和图3，这两棵就是图1有向图的生成森林。
29.图的存储结构：
1）邻接矩阵：用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。
<img width="196" alt="image" src="https://user-images.githubusercontent.com/111118849/185790012-ad56bfb0-a1d6-46d5-8d63-5c1ac2ac83f0.png">
<img width="203" alt="image" src="https://user-images.githubusercontent.com/111118849/185790026-0df09857-a061-4d40-81c7-fb236ccdb24d.png">
权值wij大多数情况下是正值，但个别时候可能就是0，甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。
<img width="215" alt="image" src="https://user-images.githubusercontent.com/111118849/185790033-b1abb8dd-9baa-4831-9a13-c63f78e32321.png">
2)邻接表:(1)图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。(2)图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。
<img width="324" alt="image" src="https://user-images.githubusercontent.com/111118849/185790040-6f62c2c9-6192-45e6-abf5-0126a2b4dddb.png">
<img width="272" alt="image" src="https://user-images.githubusercontent.com/111118849/185790045-73d123d6-241f-471c-86bd-4ce8f7d1103d.png">
<img width="345" alt="image" src="https://user-images.githubusercontent.com/111118849/185790048-8bcc402f-3044-48a9-92a2-beb6cb2b47a8.png">
3)十字链表（虚线箭头其实就是此图的逆邻接表的表示）
<img width="246" alt="image" src="https://user-images.githubusercontent.com/111118849/185790058-db338bc8-40b5-4a9d-8c95-abad921fc611.png">
4）邻接多重表
<img width="251" alt="image" src="https://user-images.githubusercontent.com/111118849/185790065-a4da1ede-3685-4667-b4d2-3a60ad823696.png">
5）边集数组：边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权组成(关注边）
<img width="416" alt="image" src="https://user-images.githubusercontent.com/111118849/185790075-05e38b4f-9d45-4a9c-b45c-f3cf79ce129a.png">
30.图的遍历：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次
31.深度优先遍历（DFS）：对连通图，从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
32.广度优先遍历（BFS）：类似于树的层序遍历
